import copy

def get_puzzle(name):
    print(f"\nEnter the {name} puzzle (3x3, use -1 for blank):")
    puzzle = []
    for i in range(3):
        row = list(map(int, input(f"Row {i+1} (space-separated 3 numbers): ").split()))
        puzzle.append(row)
    return puzzle

def move(temp, movement):
    for i in range(3):
        for j in range(3):
            if temp[i][j] == -1:
                if movement == "up" and i > 0:
                    temp[i][j], temp[i-1][j] = temp[i-1][j], temp[i][j]
                elif movement == "down" and i < 2:
                    temp[i][j], temp[i+1][j] = temp[i+1][j], temp[i][j]
                elif movement == "left" and j > 0:
                    temp[i][j], temp[i][j-1] = temp[i][j-1], temp[i][j]
                elif movement == "right" and j < 2:
                    temp[i][j], temp[i][j+1] = temp[i][j+1], temp[i][j]
                return temp
    return temp

def is_goal(state, goal):
    return state == goal

def puzzle_to_tuple(puzzle):
    return tuple(tuple(row) for row in puzzle)

def dfs(start, goal, max_depth=50):
    stack = [(start, [], [], 0)]  # (current_puzzle, path, moves, depth)
    visited = set()

    while stack:
        current, path, moves, depth = stack.pop()
        if puzzle_to_tuple(current) in visited:
            continue

        visited.add(puzzle_to_tuple(current))

        if is_goal(current, goal):
            print("\nSolution found!")
            for step in path + [current]:
                for row in step:
                    print(row)
                print()
            print("Moves:", moves)
            print("Path cost =", len(moves))
            return

        if depth >= max_depth:
            continue

        for move_dir, opposite in [("up","down"), ("left","right"), ("down","up"), ("right","left")]:
            if moves and move_dir == {"up":"down", "down":"up", "left":"right", "right":"left"}[moves[-1]]:
                continue  # avoid immediate backtracking

            new_state = move(copy.deepcopy(current), move_dir)
            if new_state != current:
                stack.append((new_state, path + [current], moves + [move_dir], depth + 1))

    print("No solution found within depth limit.")

start_puzzle = get_puzzle("start")
goal_puzzle = get_puzzle("goal")

print("\n~~~~~~~~~~~~ DFS ~~~~~~~~~~~~")
dfs(start_puzzle, goal_puzzle)

Output:
Enter the start puzzle (3x3, use -1 for blank):
Row 1 (space-separated 3 numbers): 1 -1 7
Row 2 (space-separated 3 numbers): 2 8 6
Row 3 (space-separated 3 numbers): 3 4 5

Enter the goal puzzle (3x3, use -1 for blank):
Row 1 (space-separated 3 numbers): 1 8 7
Row 2 (space-separated 3 numbers): 2 4 6
Row 3 (space-separated 3 numbers): 3 -1 5

~~~~~~~~~~~~ DFS ~~~~~~~~~~~~

Solution found!
[1, -1, 7]
[2, 8, 6]
[3, 4, 5]

[1, 7, -1]
[2, 8, 6]
[3, 4, 5]

[1, 7, 6]
[2, 8, -1]
[3, 4, 5]

[1, 7, 6]
[2, 8, 5]
[3, 4, -1]

[1, 7, 6]
[2, 8, 5]
[3, -1, 4]

[1, 7, 6]
[2, 8, 5]
[-1, 3, 4]

[1, 7, 6]
[-1, 8, 5]
[2, 3, 4]

[1, 7, 6]
[8, -1, 5]
[2, 3, 4]

[1, 7, 6]
[8, 5, -1]
[2, 3, 4]

[1, 7, 6]
[8, 5, 4]
[2, 3, -1]

[1, 7, 6]
[8, 5, 4]
[2, -1, 3]

[1, 7, 6]
[8, 5, 4]
[-1, 2, 3]

[1, 7, 6]
[-1, 5, 4]
[8, 2, 3]

[1, 7, 6]
[5, -1, 4]
[8, 2, 3]

[1, 7, 6]
[5, 4, -1]
[8, 2, 3]

[1, 7, 6]
[5, 4, 3]
[8, 2, -1]

[1, 7, 6]
[5, 4, 3]
[8, -1, 2]

[1, 7, 6]
[5, 4, 3]
[-1, 8, 2]

[1, 7, 6]
[-1, 4, 3]
[5, 8, 2]

[1, 7, 6]
[4, -1, 3]
[5, 8, 2]

[1, 7, 6]
[4, 3, -1]
[5, 8, 2]

[1, 7, 6]
[4, 3, 2]
[5, 8, -1]

[1, 7, 6]
[4, 3, 2]
[5, -1, 8]

[1, 7, 6]
[4, 3, 2]
[-1, 5, 8]

[1, 7, 6]
[-1, 3, 2]
[4, 5, 8]

[1, 7, 6]
[3, -1, 2]
[4, 5, 8]

[1, 7, 6]
[3, 2, -1]
[4, 5, 8]

[1, 7, 6]
[3, 2, 8]
[4, 5, -1]

[1, 7, 6]
[3, 2, 8]
[4, -1, 5]

[1, 7, 6]
[3, 2, 8]
[-1, 4, 5]

[1, 7, 6]
[-1, 2, 8]
[3, 4, 5]

[1, 7, 6]
[2, -1, 8]
[3, 4, 5]

[1, 7, 6]
[2, 4, 8]
[3, -1, 5]

[1, 7, 6]
[2, 4, 8]
[-1, 3, 5]

[1, 7, 6]
[-1, 4, 8]
[2, 3, 5]

[1, 7, 6]
[4, -1, 8]
[2, 3, 5]

[1, 7, 6]
[4, 8, -1]
[2, 3, 5]

[1, 7, -1]
[4, 8, 6]
[2, 3, 5]

[1, -1, 7]
[4, 8, 6]
[2, 3, 5]

[1, 8, 7]
[4, -1, 6]
[2, 3, 5]

[1, 8, 7]
[-1, 4, 6]
[2, 3, 5]

[1, 8, 7]
[2, 4, 6]
[-1, 3, 5]

[1, 8, 7]
[2, 4, 6]
[3, -1, 5]

Moves: ['right', 'down', 'down', 'left', 'left', 'up', 'right', 'right', 'down', 'left', 'left', 'up', 'right', 'right', 'down', 'left', 'left', 'up', 'right', 'right', 'down', 'left', 'left', 'up', 'right', 'right', 'down', 'left', 'left', 'up', 'right', 'down', 'left', 'up', 'right', 'right', 'up', 'left', 'down', 'left', 'down', 'right']
Path cost = 42
