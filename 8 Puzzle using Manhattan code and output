from copy import deepcopy

def read_state(prompt):
    while True:
        print(prompt)
        numbers = input().strip().split()
        if len(numbers) != 9 or not all(n.isdigit() for n in numbers):
            print("Error: Enter exactly 9 numbers separated by spaces (0 for blank). Try again.")
            continue
        numbers = list(map(int, numbers))
        
        if set(numbers) != set(range(9)):
            print("Error: Numbers must be from 0 to 8 with no duplicates. Try again.")
            continue
        return [numbers[i*3:(i+1)*3] for i in range(3)]

def find_position(state, value):
    for i in range(3):
        for j in range(3):
            if state[i][j] == value:
                return i, j
    return None

def manhattan_distance(state, goal):
    distance = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                goal_i, goal_j = find_position(goal, val)
                distance += abs(i - goal_i) + abs(j - goal_j)
    return distance

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_blank(state)
    moves = [(-1,0),(1,0),(0,-1),(0,1)]
    for dx, dy in moves:
        nx, ny = x+dx, y+dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = deepcopy(state)
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

def print_state(state):
    for row in state:
        print(row)
    print()

def hill_climbing(initial_state, goal_state, max_iterations=1000):
    current = initial_state
    current_h = manhattan_distance(current, goal_state)
    steps = 0
    
    print(f"Step {steps}: (Manhattan Distance: {current_h})")
    print_state(current)

    while steps < max_iterations:
        neighbors = get_neighbors(current)
        neighbor_h = [(manhattan_distance(n, goal_state), n) for n in neighbors]
        
        neighbor_h.sort(key=lambda x: x[0])
        best_h, best_state = neighbor_h[0]
        
        if best_h >= current_h:
            return current, current_h, steps
        
        current, current_h = best_state, best_h
        steps += 1
        
        print(f"Step {steps}: (Manhattan Distance: {current_h})")
        print_state(current)
    
    return current, current_h, steps

if __name__ == "__main__":
    initial_state = read_state("Enter the initial state (9 numbers 0-8 with 0 as blank, separated by spaces):")
    goal_state = read_state("Enter the goal state (9 numbers 0-8 with 0 as blank, separated by spaces):")
    
    print("\nInitial State:")
    print_state(initial_state)
    
    print("Goal State:")
    print_state(goal_state)
    
    final_state, h, steps = hill_climbing(initial_state, goal_state)
    
    print(f"Final State after Hill Climbing (after {steps} steps):")
    print_state(final_state)
    print(f"Manhattan Distance: {h}")
    
    if h == 0:
        print("Reached goal state!")
    else:
        print("Stopped at local minimum (not solved).")

OUTPUT:
Enter the initial state (9 numbers 0-8 with 0 as blank, separated by spaces):
1 2 3 8 6 0 7 5 4
Enter the goal state (9 numbers 0-8 with 0 as blank, separated by spaces):
1 2 3 8 0 4 7 6 5

Initial State:
[1, 2, 3]
[8, 6, 0]
[7, 5, 4]

Goal State:
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]

Step 0: (Manhattan Distance: 3)
[1, 2, 3]
[8, 6, 0]
[7, 5, 4]

Step 1: (Manhattan Distance: 2)
[1, 2, 3]
[8, 6, 4]
[7, 5, 0]

Step 2: (Manhattan Distance: 1)
[1, 2, 3]
[8, 6, 4]
[7, 0, 5]

Step 3: (Manhattan Distance: 0)
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]

Final State after Hill Climbing (after 3 steps):
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]

Manhattan Distance: 0
Reached goal state!
